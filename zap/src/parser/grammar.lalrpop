use crate::parser::syntax_tree::*;
use crate::config::{EvCall, EvSource, EvType, NumTy};

grammar;

match {
    r"\s*" => { },
    r"(--\[\[[^(\]\])]*\]\])|(--.*)" => { },
} else {
	_
}

pub Config: SyntaxConfig<'input> = {
    <start:@L> <opts:Opt*> <decls:Decl*> <end:@R> => SyntaxConfig { start, opts, decls, end },
}

Opt: SyntaxOpt<'input> = {
    <start:@L> "opt" <name:Identifier> "=" <value:OptValue> ";"? <end:@R> => SyntaxOpt { start, name, value, end },
}

OptValue: SyntaxOptValue<'input> = {
    <start:@L> <kind:OptValueKind> <end:@R> => SyntaxOptValue { start, kind, end },
}

OptValueKind: SyntaxOptValueKind<'input> = {
    StrLit => SyntaxOptValueKind::Str(<>),
    NumLit => SyntaxOptValueKind::Num(<>),
    BoolLit => SyntaxOptValueKind::Bool(<>),
}

Decl: SyntaxDecl<'input> = {
    <decl:EvDecl> => SyntaxDecl::Ev(decl),
    <decl:TyDecl> => SyntaxDecl::Ty(decl),
}

EvDecl: SyntaxEvDecl<'input> = {
    <start:@L> "event" <name:Identifier> "=" "{"
        "from" ":" <from:EvSource> ","
        "type" ":" <evty:EvTy> ","
        "call" ":" <call:EvCall> ","
        "data" ":" <data:Ty> ","?
    "}" ";"? <end:@R> => SyntaxEvDecl { start, name, from, evty, call, data, end },
}

EvCall: EvCall = {
    "SingleSync" => EvCall::SingleSync,
    "SingleAsync" => EvCall::SingleAsync,
    "ManySync" => EvCall::ManySync,
    "ManyAsync" => EvCall::ManyAsync,
}

EvTy: EvType = {
    "Reliable" => EvType::Reliable,
    "Unreliable" => EvType::Unreliable,
}

EvSource: EvSource = {
    "Server" => EvSource::Server,
    "Client" => EvSource::Client,
}

TyDecl: SyntaxTyDecl<'input> = {
    <start:@L> "type" <name:Identifier> "=" <ty:Ty> ";"? <end:@R> => SyntaxTyDecl { start, name, ty, end },
}

Ty: SyntaxTy<'input> = {
    <start:@L> <kind:TyKind> <end:@R> => SyntaxTy { start, kind, end },
}

TyKind: SyntaxTyKind<'input> = {
    "f32" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::F32, r),
    "f64" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::F64, r),

    "i8" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::I8, r),
    "i16" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::I16, r),
    "i32" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::I32, r),

    "u8" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::U8, r),
    "u16" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::U16, r),
    "u32" <r:("(" <Range> ")")?> => SyntaxTyKind::Num(NumTy::U32, r),

    "string" <r:("(" <Range> ")")?> => SyntaxTyKind::Str(r),

    <ty:Ty> "[" <r:Range?> "]" => SyntaxTyKind::Arr(Box::new(ty), r),
    "map" "{" "[" <k:Ty> "]" ":" <v:Ty> "}" => SyntaxTyKind::Map(Box::new(k), Box::new(v)),

    <ty:Ty> "?" => SyntaxTyKind::Opt(Box::new(ty)),
    <name:Identifier> => SyntaxTyKind::Ref(name),

    <e:Enum> => SyntaxTyKind::Enum(e),
    <s:Struct> => SyntaxTyKind::Struct(s),
    "Instance" <c:("(" <Identifier> ")")?> => SyntaxTyKind::Instance(c),
}

Enum: SyntaxEnum<'input> = {
    <start:@L> "enum" <kind:EnumKind> <end:@R> => SyntaxEnum { start, kind, end },
}

EnumKind: SyntaxEnumKind<'input> = {
    "{" <enumerators:Comma<Identifier>> "}" => SyntaxEnumKind::Unit(enumerators),

    <tag:StrLit> "{" <variants:Comma<(<Identifier> <Struct>)>> "}" => SyntaxEnumKind::Tagged { tag, variants },
}

Struct: SyntaxStruct<'input> = {
    <start:@L> "struct" "{" <fields:Comma<(<Identifier> ":" <Ty>)>> "}" <end:@R> => SyntaxStruct { start, fields, end },
}

Range: SyntaxRange<'input> = {
    <start:@L> <kind:RangeKind> <end:@R> => SyntaxRange { start, kind, end },
}

RangeKind: SyntaxRangeKind<'input> = {
    ".." => SyntaxRangeKind::None,
    <n:NumLit> => SyntaxRangeKind::Exact(n),
    <min:NumLit> ".." => SyntaxRangeKind::WithMin(min),
    ".." <max:NumLit> => SyntaxRangeKind::WithMax(max),
    <min:NumLit> ".." <max:NumLit> => SyntaxRangeKind::WithMinMax(min, max),
}

StrLit: SyntaxStrLit<'input> = {
    <start:@L> <value:r#""[^"]*""#> <end:@R> => SyntaxStrLit { start, value, end },
}

NumLit: SyntaxNumLit<'input> = {
    <start:@L> <value:r"-?\d+(\.\d+)?"> <end:@R> => SyntaxNumLit { start, value, end },
}

BoolLit: SyntaxBoolLit = {
    <start:@L> "true" <end:@R> => SyntaxBoolLit { start, value: true, end },
    <start:@L> "false" <end:@R> => SyntaxBoolLit { start, value: false, end },
}

Identifier: SyntaxIdentifier<'input> = {
    <start:@L> <name:r"[a-zA-Z_][a-zA-Z0-9_]*"> <end:@R> => SyntaxIdentifier { start, name, end },
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        Some(e) => { v.push(e); v },
        None => v,
    }
}
